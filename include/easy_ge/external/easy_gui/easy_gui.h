// Public Domain. See "unlicense" statement at the end of this file.

//
// QUICK NOTES
//
// General
// - easy_gui is a low-level GUI system that works on generic objects referred to as "elements".
// - An element is the most basic unit in easy_gui. It contains basic information about it's layout and hierarchy.
// - Elements can be used as the building blocks for more complex controls such as list boxes and scrollbars.
// - The layout of elements use floats instead of integers. The rationale for this is that it makes it easier to do certain
//   layout arithmetic. For example, if you want to evenly distribute 3 elements across a fixed area, the integer based
//   arithmetic can cause rounding errors which cause the elements to not sit flush against the area. By using float-based
//   arithmetic we can avoid that particular issue.
//
// Hierarchy
// - An element can have a parent and any number of children. If an element does not have a parent, it is referred to as the
//   top-level element.
// - When an element is deleted, it's children will be deleted as well.
// - Top-level elements do not have siblings.
//
// Event Handling
// - The application must notify easy_gui of application-generated events such as key strokes and mouse movements. These are
//   referred to as inbound events. An event that is generated by easy_gui are referred to as outbound events.
// - Inbound events are used to generate outbound events. For example, a mouse-move inbound event will generate an outbound
//   mouse-move event, and perhaps a mouse leave/enter pair.
// - Outbound events are posted and handled immediately. A call to easygui_post_inbound_event() will not return until all of
//   the outbound events it generates have been handled.
// - Inbound events are not thread safe, however an application is free to post an inbound event from any thread so long as
//   it does it's own synchronization.
// - Inbound events will typically specify the relevant top-level element and let easy_gui do the relevant processing required
//   to generate the appropriate outbound events. For example, the mouse-move event will be specified with respect to the top-
//   level element, but easy_gui will determine the exact child element that the mouse moved on and thus should receive the
//   relevant outbound mouse-move event.
// - There are some special events that are handled differently to normal events. The best example is the paint events. The
//   paint event is only called from easygui_draw().
// - Key press/release events are only ever posted to the element that has the keyboard capture/focus which is set with
//   easygui_capture_keyboard(). Thus, when posting an inbound key event, a top-level element is not required when posting
//   those events. The relevant context is still required, however.
//
// Global Outbound Event Handling
// - At times easy_gui will need to notify the host application in order for certain functionality to work properly. For example.
//   when the mouse is captured it won't work 100% correct unless the host application has a chance to capture the mouse against
//   the container window. Because easy_gui has no notion of a window system it relies on the host application to handle this
//   properly.
// - A global outbound event handler should be implemented for each of the following events:
//   - on_dirty: Called when a region of an element is marked as dirty and needs to be redrawn. The application will want to
//     invalidate the container window to trigger an operating system redraw. Set this with easygui_set_global_on_dirty().
//   - on_capture_mouse: Called when the mouse is captured and gives the application the opportunity to capture the mouse against
//     the container window at the operating system level. Set with easygui_set_global_on_capture_mouse().
//   - on_release_mouse: Called when the mouse is released. The opposite of on_capture_mouse.
//   - on_capture_keyboard: Called when an element is given the keyboard focus and gives the application the opportunity to
//     apply the keyboard focus to the container window. Set with easygui_set_global_on_capture_keyboard().
//   - on_release_keyboard: Called when an element loses the keyboard focus. The opposite of on_capture_keyboard.
//
// Layout
// - An element's data structure does not store it's relative position but instead stores it's absolute position. The rationale
//   for this is that storing it as relative complicates absolute positioning calculations because it would need to do a recursive
//   traversal of the element's ancestors.
// - Child elements can be scaled by setting an element's inner scale. The inner scale does not scale the element itself - only
//   it's children.
// - When an element is drawn, everything is scaled by it's inner scale. For example, if the inner scale is 2x and a 100x100 quad
//   is drawn, the quad will be scaled to 200x200. An exception to this rule is fonts, which are never scaled. This 0s because
//   text is always drawn based on the size of the font.
// - Applications should only need to work on unscaled coordinates. That is, an application should never need to worry about
//   manual scaling, except for fonts. When positioning and sizing child elements, they should be done based on unscaled
//   coordinates.
// - Use the inner scale system for DPI awareness.
// - The inner scale is applied recursively. That is, if a top level element has it's inner scale set to 2x and one of it's
//   children has an inner scale of 2x, the actual inner scale of the child element will be 4x.
//   
//
// Drawing/Painting
// - Drawing is one of the more complex parts of the GUI because it can be a bit unintuitive regarding exactly when an element
//   is drawn and when a drawing function is allowed to be called.
// - To draw an element, call easygui_draw(). This takes a pointer to the element to draw and the rectangle region that should
//   be redrawn. Any children that fall inside the specified rectangle region will be redrawn as well. You do not want to call
//   easygui_draw() on a parent element and then again on it's children because easy_gui will do that automatically.
// - easygui_draw() does not draw anything directly, but rather calls painting callback routines which is where the actual
//   drawing takes place.
// - Sometimes an application will need to be told when a region of an element is dirty and needs redrawing. An example is
//   event-driven, non real-time applications such as normal desktop applications. To mark an element as dirty, you call the
//   easygui_dirty() function which takes the element that is dirty, and the rectangle region that needs to be redrawn. This
//   does not redraw the element immediately, but instead posts an on_dirty event for the application. Marking regions as dirty
//   is not strictly required, but you should prefer it for event-driven applications that require painting operations to be
//   performed at specific times (such as inside Win32's WM_PAINT messages).
// - Some operations will cause a region of an element to become dirty - such as when it is resized. easy_gui will
//   automatically mark the relevant regions as dirty which in turn will cause a paint message to be posted. If this is not
//   required, it can be disabled with easygui_disable_auto_dirty(). You may want to disable automatic dirtying if you are
//   running a real-time application like a game which would redraw the entire GUI every frame anyway and thus not require
//   handling of the paint message.
// - Real-time application guidelines (games, etc.):
//   - easygui_disable_auto_dirty()
//   - easygui_draw(pTopLevelElement, 0, 0, viewportWidth, viewportHeight) at the end of every frame after your main loop.
//


//
// OPTIONS
//
// #define EASYGUI_NO_EASY_DRAW
//   Disable easy_draw integration. Disabling easy_draw will require you to implement your own drawing callbacks.
//


//
// EXAMPLES
//
// Basic Drawing:
//
// easygui_draw(pTopLevelElement, 0, 0, easygui_get_width(pTopLevelElement), easygui_get_height(pTopLevelElement));
//
// -------------------------
//
// Event-Driven Drawing (Win32):
//
// void my_global_on_dirty_win32(easygui_element* pElement, easygui_rect relativeRect) {
//     easygui_rect absoluteRect = relativeRect;
//     easygui_make_rect_absolute(pElement, &absoluteRect);
//
//     RECT rect;
//     rect.left   = absoluteRect.left;
//     rect.top    = absoluteRect.top;
//     rect.right  = absoluteRect.right;
//     rect.height = absoluteRect.bottom;
//     InvalidateRect((HWND)easygui_get_user_data(easygui_find_top_level_element(pElement)), &rect, FALSE);
// }
//
// ...
//
// LRESULT CALLBACK MyWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
//     ...
//     easygui_element* pTopLevelElement = (easygui_element*)GetWindowLongPtr(hWnd, 0);
//     if (pTopLevelElement != NULL) {
//         switch (msg) {
//             ...
//             case WM_PAINT:
//             {
//                 RECT rect;
//                 if (GetUpdateRect(hWnd, &rect, FALSE)) {
//                     easygui_draw(pTopLevelElement, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
//                 }
//
//                 break;
//             }
//             ...
//         }
//     }
//     ...
// }
//



#ifndef easy_gui
#define easy_gui

#ifndef EASYGUI_NO_EASY_DRAW
// If you're using easy_draw integration, set the path below to the relative location of easy_draw. By default, the
// following structure is assumed:
// <Base Directory>
//   - easy_draw
//     - easy_2d.h
//     - easy_2d.c
//   - easy_gui
//     - easy_gui.h
//     - easy_gui.c
#include "../easy_draw/easy_2d.h"
#endif

#include <stdbool.h>

#ifndef EASYGUI_MAX_FONT_FAMILY_LENGTH
#define EASYGUI_MAX_FONT_FAMILY_LENGTH  128
#endif


// Annotations.
#ifndef PRIVATE
#define PRIVATE
#endif


#ifdef __cplusplus
extern "C" {
#endif

typedef struct easygui_context easygui_context;
typedef struct easygui_element easygui_element;
typedef struct easygui_color easygui_color;
typedef struct easygui_rect easygui_rect;
typedef struct easygui_painting_callbacks easygui_painting_callbacks;
typedef struct easygui_font easygui_font;
typedef struct easygui_image easygui_image;
typedef struct easygui_font_metrics easygui_font_metrics;
typedef struct easygui_glyph_metrics easygui_glyph_metrics;

typedef unsigned char easygui_byte;
typedef unsigned int easygui_key;

typedef void* easygui_resource;


/// Font weights.
typedef enum
{
    easygui_font_weight_medium = 0,
    easygui_font_weight_thin,
    easygui_font_weight_extra_light,
    easygui_font_weight_light,
    easygui_font_weight_semi_bold,
    easygui_font_weight_bold,
    easygui_font_weight_extra_bold,
    easygui_font_weight_heavy,

    easygui_font_weight_normal  = easygui_font_weight_medium,
    easygui_font_weight_default = easygui_font_weight_medium

} easygui_font_weight;

/// Font slants.
typedef enum
{
    easygui_font_slant_none = 0,
    easygui_font_slant_italic,
    easygui_font_slant_oblique

} easygui_font_slant;


/// Font metrics.
struct easygui_font_metrics
{
    int ascent;
    int descent;
    int lineHeight;
    int spaceWidth;
};

/// Glyph metrics.
struct easygui_glyph_metrics
{
    int width;
    int height;
    int originX;
    int originY;
    int advanceX;
    int advanceY;
};


/// Structure representing an RGBA color. Color components are specified in the range of 0 - 255.
struct easygui_color
{
    easygui_byte r;
    easygui_byte g;
    easygui_byte b;
    easygui_byte a;
};

/// Structure representing a rectangle.
struct easygui_rect
{
    float left;
    float top;
    float right;
    float bottom;
};


#define EASYGUI_IMAGE_DRAW_BACKGROUND    (1 << 0)
#define EASYGUI_IMAGE_DRAW_BOUNDS        (1 << 1)
#define EASYGUI_IMAGE_CLIP_BOUNDS        (1 << 2)        //< Clips the image to the bounds
#define EASYGUI_IMAGE_ALIGN_CENTER       (1 << 3)
#define EASYGUI_IMAGE_HINT_NO_ALPHA      (1 << 4)

typedef struct
{
    /// The destination position on the x axis. This is ignored if the EASY2D_IMAGE_ALIGN_CENTER option is set.
    float dstX;

    /// The destination position on the y axis. This is ignored if the EASY2D_IMAGE_ALIGN_CENTER option is set.
    float dstY;

    /// The destination width.
    float dstWidth;

    /// The destination height.
    float dstHeight;


    /// The source offset on the x axis.
    float srcX;

    /// The source offset on the y axis.
    float srcY;

    /// The source width.
    float srcWidth;

    /// The source height.
    float srcHeight;


    /// The position of the destination's bounds on the x axis.
    float dstBoundsX;

    /// The position of the destination's bounds on the y axis.
    float dstBoundsY;

    /// The width of the destination's bounds.
    float dstBoundsWidth;

    /// The height of the destination's bounds.
    float dstBoundsHeight;


    /// The foreground tint color. This is not applied to the background color, and the alpha component is ignored.
    easygui_color foregroundTint;

    /// The background color. Only used if the EASY2D_IMAGE_DRAW_BACKGROUND option is set.
    easygui_color backgroundColor;

    /// The bounds color. This color is used for the region of the bounds that sit on the outside of the destination rectangle. This will
    /// usually be set to the same value as backgroundColor, but it could also be used to draw a border around the image.
    easygui_color boundsColor;


    /// Flags for controlling how the image should be drawn.
    unsigned int options;

} easygui_draw_image_args;


typedef void (* easygui_callback)();

typedef void (* easygui_on_move_proc)                 (easygui_element* pElement, float newRelativePosX, float newRelativePosY);
typedef void (* easygui_on_size_proc)                 (easygui_element* pElement, float newWidth, float newHeight);
typedef void (* easygui_on_mouse_enter_proc)          (easygui_element* pElement);
typedef void (* easygui_on_mouse_leave_proc)          (easygui_element* pElement);
typedef void (* easygui_on_mouse_move_proc)           (easygui_element* pElement, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* easygui_on_mouse_button_down_proc)    (easygui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* easygui_on_mouse_button_up_proc)      (easygui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* easygui_on_mouse_button_dblclick_proc)(easygui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* easygui_on_mouse_wheel_proc)          (easygui_element* pElement, int delta, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* easygui_on_key_down_proc)             (easygui_element* pElement, easygui_key key, int stateFlags);
typedef void (* easygui_on_key_up_proc)               (easygui_element* pElement, easygui_key key, int stateFlags);
typedef void (* easygui_on_printable_key_down_proc)   (easygui_element* pElement, unsigned int character, int stateFlags);
typedef void (* easygui_on_paint_proc)                (easygui_element* pElement, easygui_rect relativeRect, void* pPaintData);
typedef void (* easygui_on_dirty_proc)                (easygui_element* pElement, easygui_rect relativeRect);
typedef bool (* easygui_on_hittest_proc)              (easygui_element* pElement, float relativePosX, float relativePosY);
typedef void (* easygui_on_capture_mouse_proc)        (easygui_element* pElement);
typedef void (* easygui_on_release_mouse_proc)        (easygui_element* pElement);
typedef void (* easygui_on_capture_keyboard_proc)     (easygui_element* pElement, easygui_element* pPrevCapturedElement);
typedef void (* easygui_on_release_keyboard_proc)     (easygui_element* pElement, easygui_element* pNewCapturedElement);
typedef void (* easygui_on_log)                       (easygui_context* pContext, const char* message);

typedef void (* easygui_draw_begin_proc)                   (void* pPaintData);
typedef void (* easygui_draw_end_proc)                     (void* pPaintData);
typedef void (* easygui_set_clip_proc)                     (easygui_rect relativeRect, void* pPaintData);
typedef void (* easygui_get_clip_proc)                     (easygui_rect* pRectOut, void* pPaintData);
typedef void (* easygui_draw_line_proc)                    (float startX, float startY, float endX, float endY, float width, easygui_color color, void* pPaintData);
typedef void (* easygui_draw_rect_proc)                    (easygui_rect relativeRect, easygui_color color, void* pPaintData);
typedef void (* easygui_draw_rect_outline_proc)            (easygui_rect relativeRect, easygui_color color, float outlineWidth, void* pPaintData);
typedef void (* easygui_draw_rect_with_outline_proc)       (easygui_rect relativeRect, easygui_color color, float outlineWidth, easygui_color outlineColor, void* pPaintData);
typedef void (* easygui_draw_round_rect_proc)              (easygui_rect relativeRect, easygui_color color, float radius, void* pPaintData);
typedef void (* easygui_draw_round_rect_outline_proc)      (easygui_rect relativeRect, easygui_color color, float radius, float outlineWidth, void* pPaintData);
typedef void (* easygui_draw_round_rect_with_outline_proc) (easygui_rect relativeRect, easygui_color color, float radius, float outlineWidth, easygui_color outlineColor, void* pPaintData);
typedef void (* easygui_draw_text_proc)                    (easygui_resource font, const char* text, int textLengthInBytes, float posX, float posY, easygui_color color, easygui_color backgroundColor, void* pPaintData);
typedef void (* easygui_draw_image_proc)                   (easygui_resource image, easygui_draw_image_args* pArgs, void* pPaintData);

typedef easygui_resource (* easygui_create_font_proc)                        (void* pPaintingContext, const char* family, unsigned int size, easygui_font_weight weight, easygui_font_slant slant, float rotation);
typedef void             (* easygui_delete_font_proc)                        (easygui_resource font);
typedef unsigned int     (* easygui_get_font_size_proc)                      (easygui_resource font);
typedef bool             (* easygui_get_font_metrics_proc)                   (easygui_resource font, easygui_font_metrics* pMetricsOut);
typedef bool             (* easygui_get_glyph_metrics_proc)                  (easygui_resource font, unsigned int utf32, easygui_glyph_metrics* pMetricsOut);
typedef bool             (* easygui_measure_string_proc)                     (easygui_resource font, const char* text, size_t textSizeInBytes, float* pWidthOut, float* pHeightOut);
typedef bool             (* easygui_get_text_cursor_position_from_point_proc)(easygui_resource font, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, unsigned int* pCharacterIndexOut);
typedef bool             (* easygui_get_text_cursor_position_from_char_proc) (easygui_resource font, const char* text, unsigned int characterIndex, float* pTextCursorPosXOut);

typedef easygui_resource (* easygui_create_image_proc)     (void* pPaintingContext, unsigned int width, unsigned int height, unsigned int stride, const void* pImageData);
typedef void             (* easygui_delete_image_proc)     (easygui_resource image);
typedef void             (* easygui_get_image_size_proc)   (easygui_resource image, unsigned int* pWidthOut, unsigned int* pHeightOut);

typedef bool (* easygui_visible_iteration_proc)(easygui_element* pElement, easygui_rect *pRelativeRect, void* pUserData);


// Common mouse buttons.
#define EASYGUI_MOUSE_BUTTON_LEFT       1
#define EASYGUI_MOUSE_BUTTON_RIGHT      2
#define EASYGUI_MOUSE_BUTTON_MIDDLE     3

// Common key codes.
#define EASYGUI_BACKSPACE               0x08
#define EASYGUI_SHIFT                   0x10
#define EASYGUI_ESCAPE                  0x1B
#define EASYGUI_PAGE_UP                 0x21
#define EASYGUI_PAGE_DOWN               0x22
#define EASYGUI_END                     0x23
#define EASYGUI_HOME                    0x24
#define EASYGUI_ARROW_LEFT              0x25
#define EASYGUI_ARROW_UP                0x26
#define EASYGUI_ARROW_DOWN              0x27
#define EASYGUI_ARROW_RIGHT             0x28
#define EASYGUI_DELETE                  0x2E

// Key state flags.
#define EASYGUI_MOUSE_BUTTON_LEFT_DOWN   (1 << 0)
#define EASYGUI_MOUSE_BUTTON_RIGHT_DOWN  (1 << 1)
#define EASYGUI_MOUSE_BUTTON_MIDDLE_DOWN (1 << 2)
#define EASYGUI_MOUSE_BUTTON_4_DOWN      (1 << 3)
#define EASYGUI_MOUSE_BUTTON_5_DOWN      (1 << 4)
#define EASYGUI_KEY_STATE_SHIFT_DOWN     (1 << 5)        // Whether or not a shift key is down at the time the input event is handled.
#define EASYGUI_KEY_STATE_CTRL_DOWN      (1 << 6)        // Whether or not a ctrl key is down at the time the input event is handled.
#define EASYGUI_KEY_STATE_ALT_DOWN       (1 << 7)        // Whether or not an alt key is down at the time the input event is handled.
#define EASYGUI_KEY_STATE_AUTO_REPEATED  (1 << 31)       // Whether or not the key press is generated due to auto-repeating. Only used with key down events.




/// Structure containing callbacks for painting routines.
struct easygui_painting_callbacks
{
    easygui_draw_begin_proc                          drawBegin;
    easygui_draw_end_proc                            drawEnd;

    easygui_set_clip_proc                            setClip;
    easygui_get_clip_proc                            getClip;

    easygui_draw_line_proc                           drawLine;
    easygui_draw_rect_proc                           drawRect;
    easygui_draw_rect_outline_proc                   drawRectOutline;
    easygui_draw_rect_with_outline_proc              drawRectWithOutline;
    easygui_draw_round_rect_proc                     drawRoundRect;
    easygui_draw_round_rect_outline_proc             drawRoundRectOutline;
    easygui_draw_round_rect_with_outline_proc        drawRoundRectWithOutline;
    easygui_draw_text_proc                           drawText;
    easygui_draw_image_proc                          drawImage;

    easygui_create_font_proc                         createFont;
    easygui_delete_font_proc                         deleteFont;
    easygui_get_font_size_proc                       getFontSize;
    easygui_get_font_metrics_proc                    getFontMetrics;
    easygui_get_glyph_metrics_proc                   getGlyphMetrics;
    easygui_measure_string_proc                      measureString;
    easygui_get_text_cursor_position_from_point_proc getTextCursorPositionFromPoint;
    easygui_get_text_cursor_position_from_char_proc  getTextCursorPositionFromChar;

    easygui_create_image_proc                        createImage;
    easygui_delete_image_proc                        deleteImage;
    easygui_get_image_size_proc                      getImageSize;
};

struct easygui_image
{
    /// A pointer to the context that owns this image.
    easygui_context* pContext;

    /// The resource handle that is passed around to the callback functions.
    easygui_resource hResource;
};

struct easygui_font
{
    /// A pointer to the context that owns this font.
    easygui_context* pContext;

    /// The font family.
    char family[EASYGUI_MAX_FONT_FAMILY_LENGTH];

    /// The base size of the font. This is set to the value that was used to create the font in the first place.
    unsigned int size;

    /// The font's weight.
    easygui_font_weight weight;

    /// The fon't slant.
    easygui_font_slant slant;

    /// The fon't rotation.
    float rotation;

    /// The number of internal fonts in <pInternalFonts>
    size_t internalFontCount;

    /// A GUI font is actually a collection of font objects with the same family and style, but varying sizes. The variance
    /// in sizes is used to implement scaling. There is an internal font resource for each font size which are stored in a
    /// simple dynamically sized array. The first element in the array is the internal font representing the properties that
    /// were passed in to easygui_create_font().
    easygui_resource* pInternalFonts;
};


struct easygui_element
{
    /// A pointer to the context that owns this element. This should never be null for valid elements.
    easygui_context* pContext;


    /// A pointer to the parent element. This can be null in which case this element is the parent.
    easygui_element* pParent;

    /// A pointer to the first child element.
    easygui_element* pFirstChild;

    /// A pointer to the last child element.
    easygui_element* pLastChild;

    /// A pointer to the next sibling element.
    easygui_element* pNextSibling;

    /// A pointer ot the previous sibing element.
    easygui_element* pPrevSibling;


    /// A pointer to the next dead element. When an element is deleted during an event handler it is not deleted straight away but
    /// rather at the end of the current batch of event processing. Dead elements are stored in a linked list, with this pointer
    /// acting as the link between items. This will be null if the element is the last in the list, or is not marked as dead. Note
    /// that this should not be used to check if the element is marked as dead - use the IS_ELEMENT_DEAD flag instead.
    easygui_element* pNextDeadElement;



    /// The absolute position of the element on the x axis. A position of 0 is the left side of the surface it is attached to.
    float absolutePosX;

    /// The absolute position of the element on the y axis. A position of 0 is the top of the surface it is attached to.
    float absolutePosY;

    /// The width of the element.
    float width;

    /// The height of the element.
    float height;


    /// The scale to apply to child elements on the x axis.
    float innerScaleX;

    /// The scale to apply to child elements on the y axis.
    float innerScaleY;


    /// Boolean flags.
    unsigned int flags;


    /// The function to call when the element's relative position moves.
    easygui_on_move_proc onMove;

    /// The function to call when the element's size changes.
    easygui_on_size_proc onSize;

    /// The function to call when the mouse enters the given element.
    easygui_on_mouse_enter_proc onMouseEnter;

    /// The function to call when the mouse leaves the given element.
    easygui_on_mouse_leave_proc onMouseLeave;

    /// The function to call when the mouse is moved while over the element.
    easygui_on_mouse_move_proc onMouseMove;

    /// The function to call when a mouse buttonis pressed while over the element.
    easygui_on_mouse_button_down_proc onMouseButtonDown;

    /// The function to call when a mouse button is released while over the element.
    easygui_on_mouse_button_up_proc onMouseButtonUp;

    /// The function to call when a mouse button is double-clicked while over the element.
    easygui_on_mouse_button_dblclick_proc onMouseButtonDblClick;

    /// The function to call when the mouse wheel it turned while over the element.
    easygui_on_mouse_wheel_proc onMouseWheel;

    /// The function to call when a key on the keyboard is pressed or auto-repeated.
    easygui_on_key_down_proc onKeyDown;

    /// The function to call when a key on the keyboard is released.
    easygui_on_key_up_proc onKeyUp;

    /// The function to call when a printable character is pressed or auto-repeated. This would be used for text editing.
    easygui_on_printable_key_down_proc onPrintableKeyDown;

    /// The function to call when the paint event is received.
    easygui_on_paint_proc onPaint;

    /// The function to call when the element is marked as dirty.
    easygui_on_dirty_proc onDirty;

    /// The function to call when a hit test needs to be performed.
    easygui_on_hittest_proc onHitTest;

    /// The event handler to call when an element receives the mouse focus.
    easygui_on_capture_mouse_proc onCaptureMouse;

    /// The event handler to call when an element loses the mouse focus.
    easygui_on_release_mouse_proc onReleaseMouse;

    /// The event handler to call when an element receives the keyboard focus.
    easygui_on_capture_keyboard_proc onCaptureKeyboard;

    /// The event handler to call when an element loses the keyboard focus.
    easygui_on_release_keyboard_proc onReleaseKeyboard;


    /// The size of the extra data.
    size_t extraDataSize;

    /// A pointer to the extra data.
    easygui_byte pExtraData[1];
};

struct easygui_context
{
    /// The paiting context.
    void* pPaintingContext;

    /// The painting callbacks.
    easygui_painting_callbacks paintingCallbacks;


    /// The inbound event counter. This is incremented with easygui_begin_inbound_event() and decremented with
    /// easygui_end_inbound_event(). We use this to determine whether or not an inbound event is being processed.
    int inboundEventCounter;

    /// The outbound event counter that we use as the "lock" for outbound events. All outbound events are posted from
    /// inbound events, and all inbound events are already synchronized so we don't need to use a mutex. This is mainly
    /// used as a way to check for erroneous outbound event generation.
    int outboundEventLockCounter;

    /// A pointer to the first element that has been marked as dead. Elements marked as dead are stored as a linked list.
    easygui_element* pFirstDeadElement;

    /// A pointer to the element that is sitting directly under the mouse. This is updated on every inbound mouse move event
    /// and is used for determining when a mouse enter/leave event needs to be posted.
    easygui_element* pElementUnderMouse;

    /// A pointer to the element with the mouse capture.
    easygui_element* pElementWithMouseCapture;

    /// A pointer to the element with the keyboard focus.
    easygui_element* pElementWithKeyboardCapture;

    /// A pointer to the element that wants the keyboard focus. If for some reason an element isn't able to immediately
    /// capture the keyboard (such as while in the middle of a release_keyboard event handler) this will be set to that
    /// particular element. This will then be used to capture the keyboard at a later time when it is able.
    easygui_element* pElementWantingKeyboardCapture;


    /// Boolean flags.
    unsigned int flags;


    /// The global event callback to call when an element is marked as dirty.
    easygui_on_dirty_proc onGlobalDirty;

    /// The global event handler to call when an element captures the mouse.
    easygui_on_capture_mouse_proc onGlobalCaptureMouse;

    /// The global event handler to call when an element releases the mouse.
    easygui_on_release_mouse_proc onGlobalReleaseMouse;

    /// The global event handler to call when an element captures the keyboard.
    easygui_on_capture_keyboard_proc onGlobalCaptureKeyboard;

    /// The global event handler to call when an element releases the keyboard.
    easygui_on_release_keyboard_proc onGlobalReleaseKeyboard;


    /// The function to call when a log message is posted.
    easygui_on_log onLog;



    /// A pointer to the top level element that was passed in from the last inbound mouse move event.
    easygui_element* pLastMouseMoveTopLevelElement;

    /// The position of the mouse that was passed in from the last inbound mouse move event.
    float lastMouseMovePosX;
    float lastMouseMovePosY;


    /// A pointer to the top-level element that is currently in the process of being marked as dirty. This is set in easygui_begin_auto_dirty()
    /// and cleared in easygui_end_auto_dirty().
    easygui_element* pDirtyTopLevelElement;

    /// The current dirty rectangle, relative to pDirtyTopLevelElement.
    easygui_rect dirtyRect;

    /// The counter to use when determining whether or not an on_dirty event needs to be posted. This is incremented with
    /// easygui_begin_auto_dirty() and decremented with easygui_end_auto_dirty(). When the counter is decremented and hits
    /// zero, the on_dirty event will be posted.
    unsigned int dirtyCounter;
};



/////////////////////////////////////////////////////////////////
//
// CORE API
//
/////////////////////////////////////////////////////////////////

/// Creates a context.
easygui_context* easygui_create_context();

/// Deletes a context and everything that it created.
void easygui_delete_context(easygui_context* pContext);



/////////////////////////////////////////////////////////////////
// Events

/// Posts a mouse leave inbound event.
///
/// @remarks
///     The intention behind this event is to allow the application to let easy_gui know that the mouse have left the window. Since easy_gui does
///     not have any notion of a window it must rely on the host application to notify it.
void easygui_post_inbound_event_mouse_leave(easygui_element* pTopLevelElement);

/// Posts a mouse move inbound event.
void easygui_post_inbound_event_mouse_move(easygui_element* pTopLevelElement, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button down inbound event.
void easygui_post_inbound_event_mouse_button_down(easygui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button up inbound event.
void easygui_post_inbound_event_mouse_button_up(easygui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button double-clicked inbound event.
void easygui_post_inbound_event_mouse_button_dblclick(easygui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse wheel inbound event.
void easygui_post_inbound_event_mouse_wheel(easygui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a key down inbound event.
void easygui_post_inbound_event_key_down(easygui_context* pContext, easygui_key key, int stateFlags);

/// Posts a key up inbound event.
void easygui_post_inbound_event_key_up(easygui_context* pContext, easygui_key key, int stateFlags);

/// Posts a printable key down inbound event.
///
/// @remarks
///     The \c character argument should be a UTF-32 code point.
void easygui_post_inbound_event_printable_key_down(easygui_context* pContext, unsigned int character, int stateFlags);


/// Registers the global on_dirty event callback.
///
/// @remarks
///     This is called whenever a region of an element is marked as dirty and allows an application to mark the region of the
///     container window as dirty to trigger an operating system level repaint of the window.
void easygui_set_global_on_dirty(easygui_context* pContext, easygui_on_dirty_proc onDirty);

/// Registers the global on_capture_mouse event callback.
///
/// @remarks
///     This is called whenever an element receives an the mouse capture and allows an application to do operating system level
///     mouse captures against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void easygui_set_global_on_capture_mouse(easygui_context* pContext, easygui_on_capture_mouse_proc onCaptureMouse);

/// Registers the global on_release_mouse event callback.
///
/// @remarks
///     This is called whenever an element loses an the mouse capture and allows an application to do operating system level
///     mouse releases against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void easygui_set_global_on_release_mouse(easygui_context* pContext, easygui_on_release_mouse_proc onReleaseMouse);

/// Registers the global on_capture_keyboard event callback.
///
/// @remarks
///     This is called whenever an element receives an the keyboard capture and allows an application to do an operating system level
///     keyboard focus against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void easygui_set_global_on_capture_keyboard(easygui_context* pContext, easygui_on_capture_keyboard_proc onCaptureKeyboard);

/// Registers the global on_release_keyboard event callback.
///
/// @remarks
///     This is called whenever an element loses an the keyboard capture and allows an application to do an operating system level
///     keyboard release against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void easygui_set_global_on_release_keyboard(easygui_context* pContext, easygui_on_capture_keyboard_proc onReleaseKeyboard);


/// Registers the callback to call when a log message is posted.
void easygui_set_on_log(easygui_context* pContext, easygui_on_log onLog);




/////////////////////////////////////////////////////////////////
// Elements

/// Creates an element.
easygui_element* easygui_create_element(easygui_context* pContext, easygui_element* pParent, size_t extraDataSize, const void* pExtraData);

/// Deletes and element.
void easygui_delete_element(easygui_element* pElement);


/// Retrieves the size of the extra data of the given element, in bytes.
size_t easygui_get_extra_data_size(easygui_element* pElement);

/// Retrieves a pointer to the extra data of the given element.
void* easygui_get_extra_data(easygui_element* pElement);



/// Hides the given element.
void easygui_hide(easygui_element *pElement);

/// Shows the given element.
void easygui_show(easygui_element* pElement);

/// Determines whether or not the element is marked as visible.
///
/// @remarks
///     This is a direct accessor for the internal visible flag of the element and is not recursive. Thus, if this element is
///     marked as visible, but it's parent is invisible, it will still return true. Use easygui_is_visible_recursive() to do
///     a recursive visibility check.
bool easygui_is_visible(const easygui_element* pElement);

/// Recursively determines whether or not the element is marked as visible.
bool easygui_is_visible_recursive(const easygui_element* pElement);


/// Disables clipping against the parent for the given element.
void easygui_disable_clipping(easygui_element* pElement);

/// Enables clipping against the parent for the given element.
void easygui_enable_clipping(easygui_element* pElement);

/// Determines whether or not clipping is enabled for the given element.
bool easygui_is_clipping_enabled(const easygui_element* pElement);


/// Sets the element that should receive all future mouse related events.
///
/// @remarks
///     Release the mouse capture with easygui_release_mosue().
void easygui_capture_mouse(easygui_element* pElement);

/// Releases the mouse capture.
void easygui_release_mouse(easygui_context* pContext);

/// Retrieves a pointer to the element with the mouse capture.
easygui_element* easygui_get_element_with_mouse_capture(easygui_context* pContext);


/// Sets the element that should receive all future keyboard related events.
///
/// @remarks
///     Releases the keyboard capture with easygui_release_keyboard().
void easygui_capture_keyboard(easygui_element* pElement);

/// Releases the keyboard capture.
void easygui_release_keyboard(easygui_context* pContext);

/// Retrieves a pointer to the element with the keyboard capture.
easygui_element* easygui_get_element_with_keyboard_capture(easygui_context* pContext);


//// Events ////

/// Registers the on_move event callback.
void easygui_set_on_move(easygui_element* pElement, easygui_on_move_proc callback);

/// Registers the on_size event callback.
void easygui_set_on_size(easygui_element* pElement, easygui_on_size_proc callback);

/// Registers the on_mouse_enter event callback.
void easygui_set_on_mouse_enter(easygui_element* pElement, easygui_on_mouse_enter_proc callback);

/// Registers the on_mouse_leave event callback.
void easygui_set_on_mouse_leave(easygui_element* pElement, easygui_on_mouse_leave_proc callback);

/// Registers the on_mouse_move event callback.
void easygui_set_on_mouse_move(easygui_element* pElement, easygui_on_mouse_move_proc callback);

/// Registers the on_mouse_button_down event callback.
void easygui_set_on_mouse_button_down(easygui_element* pElement, easygui_on_mouse_button_down_proc callback);

/// Registers the on_mouse_button_up event callback.
void easygui_set_on_mouse_button_up(easygui_element* pElement, easygui_on_mouse_button_up_proc callback);

/// Registers the on_mouse_button_down event callback.
void easygui_set_on_mouse_button_dblclick(easygui_element* pElement, easygui_on_mouse_button_dblclick_proc callback);

/// Registers the on_mouse_wheel event callback.
void easygui_set_on_mouse_wheel(easygui_element* pElement, easygui_on_mouse_wheel_proc callback);

/// Registers the on_key_down event callback.
void easygui_set_on_key_down(easygui_element* pElement, easygui_on_key_down_proc callback);

/// Registers the on_key_up event callback.
void easygui_set_on_key_up(easygui_element* pElement, easygui_on_key_up_proc callback);

/// Registers the on_printable_key_down event callback.
void easygui_set_on_printable_key_down(easygui_element* pElement, easygui_on_printable_key_down_proc callback);

/// Registers the on_paint event callback.
void easygui_set_on_paint(easygui_element* pElement, easygui_on_paint_proc callback);

/// Registers the on_dirty event callback.
void easygui_set_on_dirty(easygui_element* pElement, easygui_on_dirty_proc callback);

/// Registers the on_hittest event callback.
void easygui_set_on_hittest(easygui_element* pElement, easygui_on_hittest_proc callback);

/// Registers the on_capture_mouse event callback.
void easygui_set_on_capture_mouse(easygui_element* pElement, easygui_on_capture_mouse_proc callback);

/// Registers the on_release_mouse event callback.
void easygui_set_on_release_mouse(easygui_element* pElement, easygui_on_release_mouse_proc callback);

/// Registers the on_capture_keyboard event callback.
void easygui_set_on_capture_keyboard(easygui_element* pElement, easygui_on_capture_keyboard_proc callback);

/// Registers the on_release_keyboard event callback.
void easygui_set_on_release_keyboard(easygui_element* pElement, easygui_on_release_keyboard_proc callback);



//// Containment and Hit Detection ////

/// Determines whether or not the given point is inside the bounds of the given element.
///
/// @remarks
///     This only checks if the point is inside the bounds of the element and does not take hit testing into account. This difference
///     with this one and easygui_is_point_inside_element() is that the latter will use hit testing.
bool easygui_is_point_inside_element_bounds(const easygui_element* pElement, float absolutePosX, float absolutePosY);

/// Determines whether or not the given point is inside the given element.
///
/// @remarks
///     This will use hit testing to determine whether or not the point is inside the element.
bool easygui_is_point_inside_element(easygui_element* pElement, float absolutePosX, float absolutePosY);

/// Finds the element under the given point taking mouse pass-through and hit testing into account.
easygui_element* easygui_find_element_under_point(easygui_element* pTopLevelElement, float absolutePosX, float absolutePosY);

/// Determines whether or not the given element is currently sitting directly under the mouse.
bool easygui_is_element_under_mouse(easygui_element* pTopLevelElement);



//// Hierarchy ////

/// Detaches the given element from it's parent.
void easygui_detach(easygui_element* pChildElement);

/// Attaches the given element as a child of the given parent element, and appends it to the end of the children list.
void easygui_append(easygui_element* pChildElement, easygui_element* pParentElement);

/// Attaches the given element as a child of the given parent element, and prepends it to the end of the children list.
void easygui_prepend(easygui_element* pChildElement, easygui_element* pParentElement);

/// Appends the given element to the given sibling.
void easygui_append_sibling(easygui_element* pElementToAppend, easygui_element* pElementToAppendTo);

/// Prepends the given element to the given sibling.
void easygui_prepend_sibling(easygui_element* pElementToPrepend, easygui_element* pElementToPrependTo);

/// Retrieves a pointer to the given element's top-level ancestor.
///
/// @remarks
///     If pElement is the top level element, the return value will be pElement.
easygui_element* easygui_find_top_level_element(easygui_element* pElement);

/// Determines whether or not the given element is the parent of the other.
///
/// @remarks
///     This is not recursive. Use easygui_is_ancestor() to do a recursive traversal.
bool easygui_is_parent(easygui_element* pParentElement, easygui_element* pChildElement);

/// Determines whether or not the given element is a child of the other.
///
/// @remarks
///     This is not recursive. Use easygui_is_descendant() to do a recursive traversal.
bool easygui_is_child(easygui_element* pChildElement, easygui_element* pParentElement);

/// Determines whether or not the given element is an ancestor of the other.
bool easygui_is_ancestor(easygui_element* pAncestorElement, easygui_element* pChildElement);

/// Determines whether or not the given element is a descendant of the other.
bool easygui_is_descendant(easygui_element* pChildElement, easygui_element* pAncestorElement);



//// Layout ////

/// Sets the absolute position of the given element.
void easygui_set_absolute_position(easygui_element* pElement, float positionX, float positionY);

/// Retrieves the absolute position of the given element.
void easygui_get_absolute_position(const easygui_element* pElement, float* positionXOut, float* positionYOut);
float easygui_get_absolute_position_x(const easygui_element* pElement);
float easygui_get_absolute_position_y(const easygui_element* pElement);


/// Sets the relative position of the given element.
void easygui_set_relative_position(easygui_element* pElement, float relativePosX, float relativePosY);

/// Retrieves the relative position of the given element.
void easygui_get_relative_position(const easygui_element* pElement, float* relativePosXOut, float* relativePosYOut);
float easygui_get_relative_position_x(const easygui_element* pElement);
float easygui_get_relative_position_y(const easygui_element* pElement);


/// Sets the size of the given element.
void easygui_set_size(easygui_element* pElement, float width, float height);

/// Retrieves the size of the given element.
void easygui_get_size(const easygui_element* pElement, float* widthOut, float* heightOut);
float easygui_get_width(const easygui_element* pElement);
float easygui_get_height(const easygui_element* pElement);


/// Sets the inner scale of the given element.
///
/// @remarks
///     This does not scale the element itself - only it's children.
void easygui_set_inner_scale(easygui_element* pElement, float innerScaleX, float innerScaleY);

/// Retrieves the inner scale of the given element.
///
/// @remarks
///     This is a direct accessor and not recursive. Use easygui_get_absolute_inner_scale() for the actual
///     inner scale.
void easygui_get_inner_scale(easygui_element* pElement, float* pInnerScaleXOut, float* pInnerScaleYOut);

/// Recursively retrieves the absolute scale fo the given element.
void easygui_get_absolute_inner_scale(easygui_element* pElement, float* pInnerScaleXOut, float* pInnerScaleYOut);



/// Retrieves the absolute rectangle for the given element.
easygui_rect easygui_get_absolute_rect(const easygui_element* pElement);

/// Retrieves the relative rectangle for the given element.
easygui_rect easygui_get_relative_rect(const easygui_element* pElement);

/// Retrieves the local rectangle for the given element.
///
/// @remarks
///     The local rectangle is equivalent to easygui_make_rect(0, 0, easygui_get_width(pElement), easygui_get_height(pElement));
easygui_rect easygui_get_local_rect(const easygui_element* pElement);



//// Painting ////

/// Registers the custom painting callbacks.
///
/// @remarks
///     This can only be called once, so it should always be done after initialization. This will fail if called
///     more than once.
bool easygui_register_painting_callbacks(easygui_context* pContext, void* pPaintingContext, easygui_painting_callbacks callbacks);


/// Performs a recursive traversal of all visible elements in the given rectangle.
///
/// @param pParentElement [in] A pointer to the element to iterate.
///
/// @remarks
///     pParentElement will be included in the iteration is it is within the rectangle.
///     @par
///     The rectangle should be relative to pParentElement.
///     @par
///     The iteration callback function takes a pointer to a rectangle structure that represents the visible portion of the
///     element. This pointer can be modified by the callback to create an adjusted rectangle which can be used for clipping.
bool easygui_iterate_visible_elements(easygui_element* pParentElement, easygui_rect relativeRect, easygui_visible_iteration_proc callback, void* pUserData);


/// Disable's automatic dirtying of elements.
void easygui_disable_auto_dirty(easygui_context* pContext);

/// Enable's automatic dirtying of elements.
void easygui_enable_auto_dirty(easygui_context* pContext);

/// Determines whether or not automatic dirtying is enabled.
bool easygui_is_auto_dirty_enabled(easygui_context* pContext);


/// Marks a region of the given element as dirty.
///
/// @remarks
///     This will not redraw the element immediately, but instead post a paint event.
void easygui_dirty(easygui_element* pElement, easygui_rect relativeRect);


/// Draws the given element.
///
/// @remarks
///     Do not call this on one element, then again on it's children. Any children that fall inside the specified
///     rectangle will also be redrawn.
///     @par
///     This will call painting event handlers which will give the application time to do custom drawing.
///     @par
///     When using easy_draw to do drawing, pPaintData must be set to a pointer to the relevant easydraw_surface object.
void easygui_draw(easygui_element* pElement, easygui_rect relativeRect, void* pPaintData);

/// Retrieves the current clipping rectangle.
void easygui_get_clip(easygui_element* pElement, easygui_rect* pRelativeRect, void* pPaintData);

/// Sets the clipping rectangle to apply to all future draw operations on this element.
void easygui_set_clip(easygui_element* pElement, easygui_rect relativeRect, void* pPaintData);

/// Draws a rectangle on the given element.
void easygui_draw_rect(easygui_element* pElement, easygui_rect relativeRect, easygui_color color, void* pPaintData);

/// Draws the outline of a rectangle on the given element.
void easygui_draw_rect_outline(easygui_element* pElement, easygui_rect relativeRect, easygui_color color, float outlineWidth, void* pPaintData);

/// Draws a filled rectangle with an outline on the given element.
void easygui_draw_rect_with_outline(easygui_element* pElement, easygui_rect relativeRect, easygui_color color, float outlineWidth, easygui_color outlineColor, void* pPaintData);

/// Draws a rectangle with rounded corners on the given element.
void easygui_draw_round_rect(easygui_element* pElement, easygui_rect relativeRect, easygui_color color, float radius, void* pPaintData);

/// Draws the outline of a rectangle with rounded corners on the given element.
void easygui_draw_round_rect_outline(easygui_element* pElement, easygui_rect relativeRect, easygui_color color, float radius, float outlineWidth, void* pPaintData);

/// Draws a filled rectangle and it's outline with rounded corners on the given element.
void easygui_draw_round_rect_with_outline(easygui_element* pElement, easygui_rect relativeRect, easygui_color color, float radius, float outlineWidth, easygui_color outlineColor, void* pPaintData);

/// Draws a run of text on the given element.
///
/// @remarks
///     This does not do any complex formatting like multiple lines and whatnot. Complex formatting can be achieved with multiple
///     calls to this function.
///     @par
///     \c textSizeInBytes can be -1 in which case the text string is treated as null terminated.
void easygui_draw_text(easygui_element* pElement, easygui_font* pFont, const char* text, int textLengthInBytes, float posX, float posY, easygui_color color, easygui_color backgroundColor, void* pPaintData);

/// Draws an image.
void easygui_draw_image(easygui_element* pElement, easygui_image* pImage, easygui_draw_image_args* pArgs, void* pPaintData);


/// Creates a font resource.
easygui_font* easygui_create_font(easygui_context* pContext, const char* family, unsigned int size, easygui_font_weight weight, easygui_font_slant slant, float rotation);

/// Deletes a font resource.
void easygui_delete_font(easygui_font* pFont);

/// Retrieves the metrics of the given font.
bool easygui_get_font_metrics(easygui_font* pFont, float scaleX, float scaleY, easygui_font_metrics* pMetricsOut);

/// Retrieves the metrics of the given font based on the inner scale of the given element.
bool easygui_get_font_metrics_by_element(easygui_font* pFont, easygui_element* pElement, easygui_font_metrics* pMetricsOut);

/// Retrieves the metrics of the glyph for the given character when rendered with the given font.
bool easygui_get_glyph_metrics(easygui_font* pFont, unsigned int utf32, float scaleX, float scaleY, easygui_glyph_metrics* pMetricsOut);

/// Retrieves the metrics of the glyph for the given character when rendered with the given font at the scale of the given element's inner scale.
bool easygui_get_glyph_metrics_by_element(easygui_font* pFont, unsigned int utf32, easygui_element* pElement, easygui_glyph_metrics* pMetricsOut);

/// Retrieves the dimensions of the given string when drawn with the given font at the given scale.
///
/// @remarks
///     When the length of the text is 0, the width will be set to 0 and the height will be set to the line height.
///     @par
///     <scaleX> and <scaleY> should be set to the scale at which the font will be drawn.
bool easygui_measure_string(easygui_font* pFont, const char* text, size_t textLengthInBytes, float scaleX, float scaleY, float* pWidthOut, float* pHeightOut);

/// Retrieves the dimensions fo the given string when drawing with the given font at the scale of the given element.
bool easygui_measure_string_by_element(easygui_font* pFont, const char* text, size_t textLengthInBytes, easygui_element* pElement, float* pWidthOut, float* pHeightOut);

/// Retrieves the position to place a text cursor based on the given point for the given string when drawn with the given font.
bool easygui_get_text_cursor_position_from_point(easygui_font* pFont, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float scaleX, float scaleY, float* pTextCursorPosXOut, unsigned int* pCharacterIndexOut);

/// Retrieves the position to palce a text cursor based on the character at the given index for the given string when drawn with the given font.
bool easygui_get_text_cursor_position_from_char(easygui_font* pFont, const char* text, unsigned int characterIndex, float scaleX, float scaleY, float* pTextCursorPosXOut);



/// Creates an image that can be passed to easy2d_draw_image().
///
/// @remarks
///     Images are immutable. If the data of an image needs to change, the image must be deleted and re-created.
///     @par
///     The image data must be in 32-bit, RGBA format where each component is in the range of 0 - 255.
easygui_image* easygui_create_image(easygui_context* pContext, unsigned int width, unsigned int height, unsigned int stride, const void* pData);

/// Deletes the given image.
void easygui_delete_image(easygui_image* pImage);

/// Retrieves the size of the given image.
void easygui_get_image_size(easygui_image* pImage, unsigned int* pWidthOut, unsigned int* pHeightOut);



/////////////////////////////////////////////////////////////////
//
// HIGH-LEVEL API
//
/////////////////////////////////////////////////////////////////

//// Hit Testing and Layout ////

/// An on_size event callback that resizes every child element to that of the parent.
void easygui_on_size_fit_children_to_parent(easygui_element* pElement, float newWidth, float newHeight);

/// An on_hit_test event callback that can be used to always fail the mouse hit test.
bool easygui_pass_through_hit_test(easygui_element* pElement, float mousePosX, float mousePosY);


//// Painting ////

/// Draws a border around the given element.
void easygui_draw_border(easygui_element* pElement, float borderWidth, easygui_color color, void* pUserData);



/////////////////////////////////////////////////////////////////
//
// UTILITY API
//
/////////////////////////////////////////////////////////////////

/// Creates a color object from a set of RGBA color components.
easygui_color easygui_rgba(easygui_byte r, easygui_byte g, easygui_byte b, easygui_byte a);

/// Creates a color object from a set of RGB color components.
easygui_color easygui_rgb(easygui_byte r, easygui_byte g, easygui_byte b);

/// Clamps the given rectangle to another.
easygui_rect easygui_clamp_rect(easygui_rect rect, easygui_rect other);

/// Clamps the given rectangle to the given element and returns whether or not any of it is contained within the element's rectangle.
bool easygui_clamp_rect_to_element(const easygui_element* pElement, easygui_rect* pRelativeRect);

/// Converts the given rectangle from absolute to relative to the given element.
easygui_rect easygui_make_rect_relative(const easygui_element* pElement, easygui_rect* pRect);

/// Converts the given rectangle from relative to absolute based on the given element.
easygui_rect easygui_make_rect_absolute(const easygui_element* pElement, easygui_rect* pRect);

/// Converts the given point from absolute to relative to the given element.
void easygui_make_point_relative(const easygui_element* pElement, float* positionX, float* positionY);

/// Converts the given point from relative to absolute based on the given element.
void easygui_make_point_absolute(const easygui_element* pElement, float* positionX, float* positionY);

/// Creates a easygui_rect object.
easygui_rect easygui_make_rect(float left, float top, float right, float bottom);

/// Creates an inside-out rectangle.
///
/// @remarks
///     An inside our rectangle is a negative-dimension rectangle with each edge at the extreme edges. The left edge will be at the
///     right-most side and the right edge will be at the left-most side. The same applies for the top and bottom edges.
easygui_rect easygui_make_inside_out_rect();

/// Expands the given rectangle on all sides by the given amount.
///
/// @remarks
///     This will increase the width and height of the rectangle by <amount> x 2.
///     @par
///     The growth amount can be negative, in which case it will be shrunk. Note that this does not do any checking to ensure the rectangle
///     contains positive dimensions after a shrink.
easygui_rect easygui_grow_rect(easygui_rect rect, float amount);

/// Scales the given rectangle.
///
/// @param scaleX [in] The scale to apply to <left> and <right>
/// @param scaleY [in] The scale to apply to <top> and <bottom>
///
/// @remarks
///     This will modify the <left> and <top> properties which means the rectangle will change position. To adjust only the size, scale the
///     rectangle manually.
easygui_rect easygui_scale_rect(easygui_rect rect, float scaleX, float scaleY);

/// Offsets the given rectangle.
easygui_rect easygui_offset_rect(easygui_rect rect, float offsetX, float offsetY);

/// Creates a rectangle that contains both of the given rectangles.
easygui_rect easygui_rect_union(easygui_rect rect0, easygui_rect rect1);

/// Determines whether or not the given rectangle contains the given point.
///
/// @remarks
///     An important not here is that if the position is sitting on the right or bottom border, false will be returned. If, however, the point
///     is sitting on the left or top border, true will be returned. The reason for this is that elements may sit exactly side-by-side with
///     each other, and if we use this function to determine if a point is contained within an element (which we do), we would end up having
///     this return true for both elements, which we don't want.
bool easygui_rect_contains_point(easygui_rect rect, float posX, float posY);

/// Determines whether or not two rectangles are equal.
bool easygui_rect_equal(easygui_rect rect0, easygui_rect rect1);



/////////////////////////////////////////////////////////////////
//
// EASY_DRAW-SPECIFIC API
//
/////////////////////////////////////////////////////////////////
#ifndef EASYGUI_NO_EASY_DRAW

/// A covenience function for creating a new context and registering the easy_draw painting callbacks.
///
/// @remarks
///     This is equivalent to easygui_create_context() followed by easygui_register_easy_draw_callbacks().
easygui_context* easygui_create_context_easy_draw(easy2d_context* pDrawingContext);

/// Registers the drawing callbacks for use with easy_draw.
///
/// @remarks
///     The user data of each callback is assumed to be a pointer to an easydraw_surface object.
void easygui_register_easy_draw_callbacks(easygui_context* pContext, easy2d_context* pDrawingContext);

#endif


#ifdef __cplusplus
}
#endif

#endif

/*
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>
*/
